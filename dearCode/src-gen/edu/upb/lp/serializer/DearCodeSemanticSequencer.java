/*
 * generated by Xtext 2.39.0
 */
package edu.upb.lp.serializer;

import com.google.inject.Inject;
import edu.upb.lp.dearCode.AdditiveExpression;
import edu.upb.lp.dearCode.AndExpression;
import edu.upb.lp.dearCode.BooleanLiteral;
import edu.upb.lp.dearCode.BucleFor;
import edu.upb.lp.dearCode.BucleWhile;
import edu.upb.lp.dearCode.Carta;
import edu.upb.lp.dearCode.Comment;
import edu.upb.lp.dearCode.Condicional;
import edu.upb.lp.dearCode.Cuerpo;
import edu.upb.lp.dearCode.DearCodePackage;
import edu.upb.lp.dearCode.Declarar;
import edu.upb.lp.dearCode.Despedida;
import edu.upb.lp.dearCode.Entrada;
import edu.upb.lp.dearCode.EqualityExpression;
import edu.upb.lp.dearCode.Funcion;
import edu.upb.lp.dearCode.FunctionCall;
import edu.upb.lp.dearCode.MI_ID;
import edu.upb.lp.dearCode.MultiplicativeExpression;
import edu.upb.lp.dearCode.NumberLiteral;
import edu.upb.lp.dearCode.OrExpression;
import edu.upb.lp.dearCode.ParametroDecl;
import edu.upb.lp.dearCode.Program;
import edu.upb.lp.dearCode.Reasignar;
import edu.upb.lp.dearCode.RelationalExpression;
import edu.upb.lp.dearCode.Return;
import edu.upb.lp.dearCode.Salida;
import edu.upb.lp.dearCode.Saludo;
import edu.upb.lp.dearCode.StringLiteral;
import edu.upb.lp.dearCode.UnaryExpression;
import edu.upb.lp.dearCode.VariableReference;
import edu.upb.lp.services.DearCodeGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DearCodeSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DearCodeGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DearCodePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DearCodePackage.ADDITIVE_EXPRESSION:
				sequence_AdditiveExpression(context, (AdditiveExpression) semanticObject); 
				return; 
			case DearCodePackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case DearCodePackage.BOOLEAN_LITERAL:
				sequence_PrimaryExpression(context, (BooleanLiteral) semanticObject); 
				return; 
			case DearCodePackage.BUCLE_FOR:
				sequence_BucleFor(context, (BucleFor) semanticObject); 
				return; 
			case DearCodePackage.BUCLE_WHILE:
				sequence_BucleWhile(context, (BucleWhile) semanticObject); 
				return; 
			case DearCodePackage.CARTA:
				sequence_Carta(context, (Carta) semanticObject); 
				return; 
			case DearCodePackage.COMMENT:
				sequence_Comment(context, (Comment) semanticObject); 
				return; 
			case DearCodePackage.CONDICIONAL:
				sequence_Condicional(context, (Condicional) semanticObject); 
				return; 
			case DearCodePackage.CUERPO:
				sequence_Cuerpo(context, (Cuerpo) semanticObject); 
				return; 
			case DearCodePackage.DECLARAR:
				sequence_Declarar(context, (Declarar) semanticObject); 
				return; 
			case DearCodePackage.DESPEDIDA:
				sequence_Despedida(context, (Despedida) semanticObject); 
				return; 
			case DearCodePackage.ENTRADA:
				sequence_Entrada(context, (Entrada) semanticObject); 
				return; 
			case DearCodePackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case DearCodePackage.FUNCION:
				sequence_Funcion(context, (Funcion) semanticObject); 
				return; 
			case DearCodePackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case DearCodePackage.MI_ID:
				sequence_MI_ID(context, (MI_ID) semanticObject); 
				return; 
			case DearCodePackage.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case DearCodePackage.NUMBER_LITERAL:
				sequence_PrimaryExpression(context, (NumberLiteral) semanticObject); 
				return; 
			case DearCodePackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case DearCodePackage.PARAMETRO_DECL:
				sequence_ParametroDecl(context, (ParametroDecl) semanticObject); 
				return; 
			case DearCodePackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case DearCodePackage.REASIGNAR:
				sequence_Reasignar(context, (Reasignar) semanticObject); 
				return; 
			case DearCodePackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case DearCodePackage.RETURN:
				sequence_Return(context, (Return) semanticObject); 
				return; 
			case DearCodePackage.SALIDA:
				sequence_Salida(context, (Salida) semanticObject); 
				return; 
			case DearCodePackage.SALUDO:
				sequence_Saludo(context, (Saludo) semanticObject); 
				return; 
			case DearCodePackage.STRING_LITERAL:
				sequence_PrimaryExpression(context, (StringLiteral) semanticObject); 
				return; 
			case DearCodePackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case DearCodePackage.VARIABLE_REFERENCE:
				sequence_PrimaryExpression(context, (VariableReference) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AdditiveExpression
	 *     OrExpression returns AdditiveExpression
	 *     OrExpression.OrExpression_1_0 returns AdditiveExpression
	 *     AndExpression returns AdditiveExpression
	 *     AndExpression.AndExpression_1_0 returns AdditiveExpression
	 *     EqualityExpression returns AdditiveExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns AdditiveExpression
	 *     RelationalExpression returns AdditiveExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns AdditiveExpression
	 *     AdditiveExpression returns AdditiveExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns AdditiveExpression
	 *     MultiplicativeExpression returns AdditiveExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns AdditiveExpression
	 *     UnaryExpression returns AdditiveExpression
	 *     PrimaryExpression returns AdditiveExpression
	 *
	 * Constraint:
	 *     (
	 *         left=AdditiveExpression_AdditiveExpression_1_0 
	 *         (
	 *             op='unidos en un solo suspiro con' | 
	 *             op='fundidos en la llama de' | 
	 *             op='se une a' | 
	 *             op='se funde con' | 
	 *             op='sumado al latido de' | 
	 *             op='combinado con la pasión de' | 
	 *             op='entrelazado con' | 
	 *             op='añadido al suspiro de'
	 *         ) 
	 *         right=MultiplicativeExpression
	 *     )
	 * </pre>
	 */
	protected void sequence_AdditiveExpression(ISerializationContext context, AdditiveExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AndExpression
	 *     OrExpression returns AndExpression
	 *     OrExpression.OrExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *     EqualityExpression returns AndExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns AndExpression
	 *     RelationalExpression returns AndExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns AndExpression
	 *     AdditiveExpression returns AndExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns AndExpression
	 *     MultiplicativeExpression returns AndExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns AndExpression
	 *     UnaryExpression returns AndExpression
	 *     PrimaryExpression returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 right=EqualityExpression)
	 * </pre>
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightEqualityExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruccion returns BucleFor
	 *     ElementoBloque returns BucleFor
	 *     BucleFor returns BucleFor
	 *
	 * Constraint:
	 *     (variable=MI_ID inicio=Expression fin=Expression paso=Expression? loopBody+=ElementoBloque+)
	 * </pre>
	 */
	protected void sequence_BucleFor(ISerializationContext context, BucleFor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruccion returns BucleWhile
	 *     ElementoBloque returns BucleWhile
	 *     BucleWhile returns BucleWhile
	 *
	 * Constraint:
	 *     (condicion=Expression loopBody+=ElementoBloque+)
	 * </pre>
	 */
	protected void sequence_BucleWhile(ISerializationContext context, BucleWhile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Carta returns Carta
	 *
	 * Constraint:
	 *     (saludo=Saludo cuerpo=Cuerpo despedida=Despedida)
	 * </pre>
	 */
	protected void sequence_Carta(ISerializationContext context, Carta semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.CARTA__SALUDO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.CARTA__SALUDO));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.CARTA__CUERPO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.CARTA__CUERPO));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.CARTA__DESPEDIDA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.CARTA__DESPEDIDA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCartaAccess().getSaludoSaludoParserRuleCall_0_0(), semanticObject.getSaludo());
		feeder.accept(grammarAccess.getCartaAccess().getCuerpoCuerpoParserRuleCall_1_0(), semanticObject.getCuerpo());
		feeder.accept(grammarAccess.getCartaAccess().getDespedidaDespedidaParserRuleCall_2_0(), semanticObject.getDespedida());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Comment returns Comment
	 *
	 * Constraint:
	 *     value=ANYTEXT
	 * </pre>
	 */
	protected void sequence_Comment(ISerializationContext context, Comment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.COMMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.COMMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommentAccess().getValueANYTEXTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruccion returns Condicional
	 *     ElementoBloque returns Condicional
	 *     Condicional returns Condicional
	 *
	 * Constraint:
	 *     (condicion=Expression comment+=Comment? instruccionesThen+=ElementoBloque+ instruccionesElse+=ElementoBloque*)
	 * </pre>
	 */
	protected void sequence_Condicional(ISerializationContext context, Condicional semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Cuerpo returns Cuerpo
	 *
	 * Constraint:
	 *     instrucciones+=Instruccion+
	 * </pre>
	 */
	protected void sequence_Cuerpo(ISerializationContext context, Cuerpo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruccion returns Declarar
	 *     Declarar returns Declarar
	 *     ElementoBloque returns Declarar
	 *
	 * Constraint:
	 *     (
	 *         verboDecl=VerboDeclaracion 
	 *         articulo=Articulo 
	 *         tipo=Type? 
	 *         sustantivo=MI_ID 
	 *         preComentario=Comment? 
	 *         valor=Expression 
	 *         postComentario=Comment?
	 *     )
	 * </pre>
	 */
	protected void sequence_Declarar(ISerializationContext context, Declarar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Despedida returns Despedida
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Despedida(ISerializationContext context, Despedida semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.DESPEDIDA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.DESPEDIDA__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDespedidaAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruccion returns Entrada
	 *     Entrada returns Entrada
	 *     ElementoBloque returns Entrada
	 *
	 * Constraint:
	 *     variable=MI_ID
	 * </pre>
	 */
	protected void sequence_Entrada(ISerializationContext context, Entrada semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.ENTRADA__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.ENTRADA__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntradaAccess().getVariableMI_IDParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns EqualityExpression
	 *     OrExpression returns EqualityExpression
	 *     OrExpression.OrExpression_1_0 returns EqualityExpression
	 *     AndExpression returns EqualityExpression
	 *     AndExpression.AndExpression_1_0 returns EqualityExpression
	 *     EqualityExpression returns EqualityExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns EqualityExpression
	 *     RelationalExpression returns EqualityExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns EqualityExpression
	 *     AdditiveExpression returns EqualityExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns EqualityExpression
	 *     MultiplicativeExpression returns EqualityExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns EqualityExpression
	 *     UnaryExpression returns EqualityExpression
	 *     PrimaryExpression returns EqualityExpression
	 *
	 * Constraint:
	 *     (
	 *         left=EqualityExpression_EqualityExpression_1_0 
	 *         (
	 *             op='late al unísono con' | 
	 *             op='canta con un matiz distinto a' | 
	 *             op='late igual que' | 
	 *             op='se distingue de' | 
	 *             op='resuena igual que' | 
	 *             op='vibra al mismo ritmo que' | 
	 *             op='es idéntico a' | 
	 *             op='se diferencia de' | 
	 *             op='no coincide con' | 
	 *             op='es distinto a'
	 *         ) 
	 *         right=RelationalExpression
	 *     )
	 * </pre>
	 */
	protected void sequence_EqualityExpression(ISerializationContext context, EqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruccion returns Funcion
	 *     ElementoBloque returns Funcion
	 *     Funcion returns Funcion
	 *
	 * Constraint:
	 *     (name=MI_ID (parametros+=ParametroDecl parametros+=ParametroDecl*)? tipo=Type? instrucciones+=ElementoBloque+)
	 * </pre>
	 */
	protected void sequence_Funcion(ISerializationContext context, Funcion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruccion returns FunctionCall
	 *     ElementoBloque returns FunctionCall
	 *     Expression returns FunctionCall
	 *     OrExpression returns FunctionCall
	 *     OrExpression.OrExpression_1_0 returns FunctionCall
	 *     AndExpression returns FunctionCall
	 *     AndExpression.AndExpression_1_0 returns FunctionCall
	 *     EqualityExpression returns FunctionCall
	 *     EqualityExpression.EqualityExpression_1_0 returns FunctionCall
	 *     RelationalExpression returns FunctionCall
	 *     RelationalExpression.RelationalExpression_1_0 returns FunctionCall
	 *     AdditiveExpression returns FunctionCall
	 *     AdditiveExpression.AdditiveExpression_1_0 returns FunctionCall
	 *     MultiplicativeExpression returns FunctionCall
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns FunctionCall
	 *     UnaryExpression returns FunctionCall
	 *     PrimaryExpression returns FunctionCall
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (nameFuncion=[MI_ID|ID] (args+=Expression args+=Expression*)?)
	 * </pre>
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MI_ID returns MI_ID
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_MI_ID(ISerializationContext context, MI_ID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.MI_ID__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.MI_ID__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMI_IDAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns MultiplicativeExpression
	 *     OrExpression returns MultiplicativeExpression
	 *     OrExpression.OrExpression_1_0 returns MultiplicativeExpression
	 *     AndExpression returns MultiplicativeExpression
	 *     AndExpression.AndExpression_1_0 returns MultiplicativeExpression
	 *     EqualityExpression returns MultiplicativeExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns MultiplicativeExpression
	 *     RelationalExpression returns MultiplicativeExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns MultiplicativeExpression
	 *     AdditiveExpression returns MultiplicativeExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns MultiplicativeExpression
	 *     MultiplicativeExpression returns MultiplicativeExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns MultiplicativeExpression
	 *     UnaryExpression returns MultiplicativeExpression
	 *     PrimaryExpression returns MultiplicativeExpression
	 *
	 * Constraint:
	 *     (
	 *         left=MultiplicativeExpression_MultiplicativeExpression_1_0 
	 *         (
	 *             op='fortalecidos por el fuego de' | 
	 *             op='separados entre los ecos de' | 
	 *             op='resuena con el eco de' | 
	 *             op='crece con' | 
	 *             op='resuena en' | 
	 *             op='se divide entre'
	 *         ) 
	 *         right=UnaryExpression
	 *     )
	 * </pre>
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, MultiplicativeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns OrExpression
	 *     OrExpression returns OrExpression
	 *     OrExpression.OrExpression_1_0 returns OrExpression
	 *     AndExpression returns OrExpression
	 *     AndExpression.AndExpression_1_0 returns OrExpression
	 *     EqualityExpression returns OrExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns OrExpression
	 *     RelationalExpression returns OrExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns OrExpression
	 *     AdditiveExpression returns OrExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns OrExpression
	 *     MultiplicativeExpression returns OrExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns OrExpression
	 *     UnaryExpression returns OrExpression
	 *     PrimaryExpression returns OrExpression
	 *
	 * Constraint:
	 *     (left=OrExpression_OrExpression_1_0 right=AndExpression)
	 * </pre>
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParametroDecl returns ParametroDecl
	 *
	 * Constraint:
	 *     (tipo=Type? comment+=Comment? name=MI_ID)
	 * </pre>
	 */
	protected void sequence_ParametroDecl(ISerializationContext context, ParametroDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BooleanLiteral
	 *     OrExpression returns BooleanLiteral
	 *     OrExpression.OrExpression_1_0 returns BooleanLiteral
	 *     AndExpression returns BooleanLiteral
	 *     AndExpression.AndExpression_1_0 returns BooleanLiteral
	 *     EqualityExpression returns BooleanLiteral
	 *     EqualityExpression.EqualityExpression_1_0 returns BooleanLiteral
	 *     RelationalExpression returns BooleanLiteral
	 *     RelationalExpression.RelationalExpression_1_0 returns BooleanLiteral
	 *     AdditiveExpression returns BooleanLiteral
	 *     AdditiveExpression.AdditiveExpression_1_0 returns BooleanLiteral
	 *     MultiplicativeExpression returns BooleanLiteral
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns BooleanLiteral
	 *     UnaryExpression returns BooleanLiteral
	 *     PrimaryExpression returns BooleanLiteral
	 *
	 * Constraint:
	 *     (valueBoolean='siempre' | valueBoolean='jamás')
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NumberLiteral
	 *     OrExpression returns NumberLiteral
	 *     OrExpression.OrExpression_1_0 returns NumberLiteral
	 *     AndExpression returns NumberLiteral
	 *     AndExpression.AndExpression_1_0 returns NumberLiteral
	 *     EqualityExpression returns NumberLiteral
	 *     EqualityExpression.EqualityExpression_1_0 returns NumberLiteral
	 *     RelationalExpression returns NumberLiteral
	 *     RelationalExpression.RelationalExpression_1_0 returns NumberLiteral
	 *     AdditiveExpression returns NumberLiteral
	 *     AdditiveExpression.AdditiveExpression_1_0 returns NumberLiteral
	 *     MultiplicativeExpression returns NumberLiteral
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns NumberLiteral
	 *     UnaryExpression returns NumberLiteral
	 *     PrimaryExpression returns NumberLiteral
	 *
	 * Constraint:
	 *     valueInt=INT
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.NUMBER_LITERAL__VALUE_INT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.NUMBER_LITERAL__VALUE_INT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getValueIntINTTerminalRuleCall_1_1_0(), semanticObject.getValueInt());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     OrExpression returns StringLiteral
	 *     OrExpression.OrExpression_1_0 returns StringLiteral
	 *     AndExpression returns StringLiteral
	 *     AndExpression.AndExpression_1_0 returns StringLiteral
	 *     EqualityExpression returns StringLiteral
	 *     EqualityExpression.EqualityExpression_1_0 returns StringLiteral
	 *     RelationalExpression returns StringLiteral
	 *     RelationalExpression.RelationalExpression_1_0 returns StringLiteral
	 *     AdditiveExpression returns StringLiteral
	 *     AdditiveExpression.AdditiveExpression_1_0 returns StringLiteral
	 *     MultiplicativeExpression returns StringLiteral
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns StringLiteral
	 *     UnaryExpression returns StringLiteral
	 *     PrimaryExpression returns StringLiteral
	 *
	 * Constraint:
	 *     valueString=STRING
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.STRING_LITERAL__VALUE_STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.STRING_LITERAL__VALUE_STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getValueStringSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValueString());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns VariableReference
	 *     OrExpression returns VariableReference
	 *     OrExpression.OrExpression_1_0 returns VariableReference
	 *     AndExpression returns VariableReference
	 *     AndExpression.AndExpression_1_0 returns VariableReference
	 *     EqualityExpression returns VariableReference
	 *     EqualityExpression.EqualityExpression_1_0 returns VariableReference
	 *     RelationalExpression returns VariableReference
	 *     RelationalExpression.RelationalExpression_1_0 returns VariableReference
	 *     AdditiveExpression returns VariableReference
	 *     AdditiveExpression.AdditiveExpression_1_0 returns VariableReference
	 *     MultiplicativeExpression returns VariableReference
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns VariableReference
	 *     UnaryExpression returns VariableReference
	 *     PrimaryExpression returns VariableReference
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, VariableReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.VARIABLE_REFERENCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.VARIABLE_REFERENCE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getNameIDTerminalRuleCall_4_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     carta=Carta
	 * </pre>
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.PROGRAM__CARTA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.PROGRAM__CARTA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProgramAccess().getCartaCartaParserRuleCall_0(), semanticObject.getCarta());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruccion returns Reasignar
	 *     Reasignar returns Reasignar
	 *     ElementoBloque returns Reasignar
	 *
	 * Constraint:
	 *     (
	 *         verboReas=VerboReasignacion 
	 *         preComentario=Comment? 
	 *         sustantivo=MI_ID 
	 *         postComentario=Comment? 
	 *         valor=Expression 
	 *         comentario=Comment?
	 *     )
	 * </pre>
	 */
	protected void sequence_Reasignar(ISerializationContext context, Reasignar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns RelationalExpression
	 *     OrExpression returns RelationalExpression
	 *     OrExpression.OrExpression_1_0 returns RelationalExpression
	 *     AndExpression returns RelationalExpression
	 *     AndExpression.AndExpression_1_0 returns RelationalExpression
	 *     EqualityExpression returns RelationalExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns RelationalExpression
	 *     RelationalExpression returns RelationalExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns RelationalExpression
	 *     AdditiveExpression returns RelationalExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns RelationalExpression
	 *     MultiplicativeExpression returns RelationalExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns RelationalExpression
	 *     UnaryExpression returns RelationalExpression
	 *     PrimaryExpression returns RelationalExpression
	 *
	 * Constraint:
	 *     (
	 *         left=RelationalExpression_RelationalExpression_1_0 
	 *         (
	 *             op='susurra con menos fuerza que' | 
	 *             op='casi suspira al mismo nivel que' | 
	 *             op='arde con más pasión que' | 
	 *             op='rodea con tanta fuerza como' | 
	 *             op='susurra menos que' | 
	 *             op='casi igual que' | 
	 *             op='arde mas que' | 
	 *             op='abraza como' | 
	 *             op='susurra más suavemente que' | 
	 *             op='tiene menos latidos que' | 
	 *             op='susurra tan suavemente como' | 
	 *             op='no supera a' | 
	 *             op='susurra con más fuerza que' | 
	 *             op='tiene más latidos que' | 
	 *             op='susurra al menos con la misma fuerza que' | 
	 *             op='al menos iguala a'
	 *         ) 
	 *         right=AdditiveExpression
	 *     )
	 * </pre>
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, RelationalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ElementoBloque returns Return
	 *     Return returns Return
	 *
	 * Constraint:
	 *     expresion=Expression
	 * </pre>
	 */
	protected void sequence_Return(ISerializationContext context, Return semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.RETURN__EXPRESION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.RETURN__EXPRESION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnAccess().getExpresionExpressionParserRuleCall_1_0(), semanticObject.getExpresion());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruccion returns Salida
	 *     Salida returns Salida
	 *     ElementoBloque returns Salida
	 *
	 * Constraint:
	 *     expresion=Expression
	 * </pre>
	 */
	protected void sequence_Salida(ISerializationContext context, Salida semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.SALIDA__EXPRESION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.SALIDA__EXPRESION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSalidaAccess().getExpresionExpressionParserRuleCall_1_0(), semanticObject.getExpresion());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Saludo returns Saludo
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Saludo(ISerializationContext context, Saludo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.SALUDO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.SALUDO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSaludoAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns UnaryExpression
	 *     OrExpression returns UnaryExpression
	 *     OrExpression.OrExpression_1_0 returns UnaryExpression
	 *     AndExpression returns UnaryExpression
	 *     AndExpression.AndExpression_1_0 returns UnaryExpression
	 *     EqualityExpression returns UnaryExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns UnaryExpression
	 *     RelationalExpression returns UnaryExpression
	 *     RelationalExpression.RelationalExpression_1_0 returns UnaryExpression
	 *     AdditiveExpression returns UnaryExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns UnaryExpression
	 *     MultiplicativeExpression returns UnaryExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns UnaryExpression
	 *     UnaryExpression returns UnaryExpression
	 *     PrimaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     ((op='no creo que' | op='no siento que' | op='no me parece que' | op='no percibo que' | op='dudo que') expression=UnaryExpression)
	 * </pre>
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
