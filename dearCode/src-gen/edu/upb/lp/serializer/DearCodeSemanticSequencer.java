/*
 * generated by Xtext 2.39.0
 */
package edu.upb.lp.serializer;

import com.google.inject.Inject;
import edu.upb.lp.dearCode.AdditiveExpr;
import edu.upb.lp.dearCode.AndExpr;
import edu.upb.lp.dearCode.BooleanLiteral;
import edu.upb.lp.dearCode.BucleFor;
import edu.upb.lp.dearCode.BucleWhile;
import edu.upb.lp.dearCode.Carta;
import edu.upb.lp.dearCode.Condicional;
import edu.upb.lp.dearCode.Cuerpo;
import edu.upb.lp.dearCode.DearCodePackage;
import edu.upb.lp.dearCode.Despedida;
import edu.upb.lp.dearCode.EqualityExpr;
import edu.upb.lp.dearCode.IntLiteral;
import edu.upb.lp.dearCode.MultiplicativeExpr;
import edu.upb.lp.dearCode.NotExpr;
import edu.upb.lp.dearCode.OrExpr;
import edu.upb.lp.dearCode.Program;
import edu.upb.lp.dearCode.RelationalExpr;
import edu.upb.lp.dearCode.Saludo;
import edu.upb.lp.dearCode.StringLiteral;
import edu.upb.lp.dearCode.VariableRef;
import edu.upb.lp.services.DearCodeGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DearCodeSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DearCodeGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DearCodePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DearCodePackage.ADDITIVE_EXPR:
				sequence_AdditiveExpr(context, (AdditiveExpr) semanticObject); 
				return; 
			case DearCodePackage.AND_EXPR:
				sequence_AndExpr(context, (AndExpr) semanticObject); 
				return; 
			case DearCodePackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case DearCodePackage.BUCLE_FOR:
				sequence_BucleFor(context, (BucleFor) semanticObject); 
				return; 
			case DearCodePackage.BUCLE_WHILE:
				sequence_BucleWhile(context, (BucleWhile) semanticObject); 
				return; 
			case DearCodePackage.CARTA:
				sequence_Carta(context, (Carta) semanticObject); 
				return; 
			case DearCodePackage.CONDICIONAL:
				sequence_Condicional(context, (Condicional) semanticObject); 
				return; 
			case DearCodePackage.CUERPO:
				sequence_Cuerpo(context, (Cuerpo) semanticObject); 
				return; 
			case DearCodePackage.DESPEDIDA:
				sequence_Despedida(context, (Despedida) semanticObject); 
				return; 
			case DearCodePackage.EQUALITY_EXPR:
				sequence_EqualityExpr(context, (EqualityExpr) semanticObject); 
				return; 
			case DearCodePackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case DearCodePackage.MULTIPLICATIVE_EXPR:
				sequence_MultiplicativeExpr(context, (MultiplicativeExpr) semanticObject); 
				return; 
			case DearCodePackage.NOT_EXPR:
				sequence_UnaryExpr(context, (NotExpr) semanticObject); 
				return; 
			case DearCodePackage.OR_EXPR:
				sequence_OrExpr(context, (OrExpr) semanticObject); 
				return; 
			case DearCodePackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case DearCodePackage.RELATIONAL_EXPR:
				sequence_RelationalExpr(context, (RelationalExpr) semanticObject); 
				return; 
			case DearCodePackage.SALUDO:
				sequence_Saludo(context, (Saludo) semanticObject); 
				return; 
			case DearCodePackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case DearCodePackage.VARIABLE_REF:
				sequence_VariableRef(context, (VariableRef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condicion returns AdditiveExpr
	 *     Expression returns AdditiveExpr
	 *     OrExpr returns AdditiveExpr
	 *     OrExpr.OrExpr_1_0 returns AdditiveExpr
	 *     AndExpr returns AdditiveExpr
	 *     AndExpr.AndExpr_1_0 returns AdditiveExpr
	 *     EqualityExpr returns AdditiveExpr
	 *     EqualityExpr.EqualityExpr_1_0 returns AdditiveExpr
	 *     RelationalExpr returns AdditiveExpr
	 *     RelationalExpr.RelationalExpr_1_0 returns AdditiveExpr
	 *     AdditiveExpr returns AdditiveExpr
	 *     AdditiveExpr.AdditiveExpr_1_0 returns AdditiveExpr
	 *     MultiplicativeExpr returns AdditiveExpr
	 *     MultiplicativeExpr.MultiplicativeExpr_1_0 returns AdditiveExpr
	 *     UnaryExpr returns AdditiveExpr
	 *     PrimaryExpr returns AdditiveExpr
	 *
	 * Constraint:
	 *     (left=AdditiveExpr_AdditiveExpr_1_0 right=MultiplicativeExpr)
	 * </pre>
	 */
	protected void sequence_AdditiveExpr(ISerializationContext context, AdditiveExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.ADDITIVE_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.ADDITIVE_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.ADDITIVE_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.ADDITIVE_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditiveExprAccess().getAdditiveExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditiveExprAccess().getRightMultiplicativeExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condicion returns AndExpr
	 *     Expression returns AndExpr
	 *     OrExpr returns AndExpr
	 *     OrExpr.OrExpr_1_0 returns AndExpr
	 *     AndExpr returns AndExpr
	 *     AndExpr.AndExpr_1_0 returns AndExpr
	 *     EqualityExpr returns AndExpr
	 *     EqualityExpr.EqualityExpr_1_0 returns AndExpr
	 *     RelationalExpr returns AndExpr
	 *     RelationalExpr.RelationalExpr_1_0 returns AndExpr
	 *     AdditiveExpr returns AndExpr
	 *     AdditiveExpr.AdditiveExpr_1_0 returns AndExpr
	 *     MultiplicativeExpr returns AndExpr
	 *     MultiplicativeExpr.MultiplicativeExpr_1_0 returns AndExpr
	 *     UnaryExpr returns AndExpr
	 *     PrimaryExpr returns AndExpr
	 *
	 * Constraint:
	 *     (left=AndExpr_AndExpr_1_0 right=EqualityExpr)
	 * </pre>
	 */
	protected void sequence_AndExpr(ISerializationContext context, AndExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.AND_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.AND_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.AND_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.AND_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExprAccess().getAndExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExprAccess().getRightEqualityExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condicion returns BooleanLiteral
	 *     Expression returns BooleanLiteral
	 *     OrExpr returns BooleanLiteral
	 *     OrExpr.OrExpr_1_0 returns BooleanLiteral
	 *     AndExpr returns BooleanLiteral
	 *     AndExpr.AndExpr_1_0 returns BooleanLiteral
	 *     EqualityExpr returns BooleanLiteral
	 *     EqualityExpr.EqualityExpr_1_0 returns BooleanLiteral
	 *     RelationalExpr returns BooleanLiteral
	 *     RelationalExpr.RelationalExpr_1_0 returns BooleanLiteral
	 *     AdditiveExpr returns BooleanLiteral
	 *     AdditiveExpr.AdditiveExpr_1_0 returns BooleanLiteral
	 *     MultiplicativeExpr returns BooleanLiteral
	 *     MultiplicativeExpr.MultiplicativeExpr_1_0 returns BooleanLiteral
	 *     UnaryExpr returns BooleanLiteral
	 *     PrimaryExpr returns BooleanLiteral
	 *     Literal returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     (value='siempre' | value='jam√°s')
	 * </pre>
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruccion returns BucleFor
	 *     BucleFor returns BucleFor
	 *
	 * Constraint:
	 *     (condicion=Condicion accionStop=Instruccion accion=Instruccion)
	 * </pre>
	 */
	protected void sequence_BucleFor(ISerializationContext context, BucleFor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.INSTRUCCION__CONDICION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.INSTRUCCION__CONDICION));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.BUCLE_FOR__ACCION_STOP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.BUCLE_FOR__ACCION_STOP));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.INSTRUCCION__ACCION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.INSTRUCCION__ACCION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBucleForAccess().getCondicionCondicionParserRuleCall_1_0(), semanticObject.getCondicion());
		feeder.accept(grammarAccess.getBucleForAccess().getAccionStopInstruccionParserRuleCall_3_0(), semanticObject.getAccionStop());
		feeder.accept(grammarAccess.getBucleForAccess().getAccionInstruccionParserRuleCall_5_0(), semanticObject.getAccion());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruccion returns BucleWhile
	 *     BucleWhile returns BucleWhile
	 *
	 * Constraint:
	 *     (condicion=Condicion accion=Instruccion)
	 * </pre>
	 */
	protected void sequence_BucleWhile(ISerializationContext context, BucleWhile semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.INSTRUCCION__CONDICION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.INSTRUCCION__CONDICION));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.INSTRUCCION__ACCION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.INSTRUCCION__ACCION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBucleWhileAccess().getCondicionCondicionParserRuleCall_1_0(), semanticObject.getCondicion());
		feeder.accept(grammarAccess.getBucleWhileAccess().getAccionInstruccionParserRuleCall_3_0(), semanticObject.getAccion());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Carta returns Carta
	 *
	 * Constraint:
	 *     (saludo=Saludo cuerpo=Cuerpo despedida=Despedida)
	 * </pre>
	 */
	protected void sequence_Carta(ISerializationContext context, Carta semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.CARTA__SALUDO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.CARTA__SALUDO));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.CARTA__CUERPO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.CARTA__CUERPO));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.CARTA__DESPEDIDA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.CARTA__DESPEDIDA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCartaAccess().getSaludoSaludoParserRuleCall_0_0(), semanticObject.getSaludo());
		feeder.accept(grammarAccess.getCartaAccess().getCuerpoCuerpoParserRuleCall_1_0(), semanticObject.getCuerpo());
		feeder.accept(grammarAccess.getCartaAccess().getDespedidaDespedidaParserRuleCall_2_0(), semanticObject.getDespedida());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruccion returns Condicional
	 *     Condicional returns Condicional
	 *
	 * Constraint:
	 *     (condicion=Condicion accion=Instruccion accionElse=Instruccion?)
	 * </pre>
	 */
	protected void sequence_Condicional(ISerializationContext context, Condicional semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Cuerpo returns Cuerpo
	 *
	 * Constraint:
	 *     instrucciones+=Instruccion+
	 * </pre>
	 */
	protected void sequence_Cuerpo(ISerializationContext context, Cuerpo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Despedida returns Despedida
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Despedida(ISerializationContext context, Despedida semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.DESPEDIDA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.DESPEDIDA__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDespedidaAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condicion returns EqualityExpr
	 *     Expression returns EqualityExpr
	 *     OrExpr returns EqualityExpr
	 *     OrExpr.OrExpr_1_0 returns EqualityExpr
	 *     AndExpr returns EqualityExpr
	 *     AndExpr.AndExpr_1_0 returns EqualityExpr
	 *     EqualityExpr returns EqualityExpr
	 *     EqualityExpr.EqualityExpr_1_0 returns EqualityExpr
	 *     RelationalExpr returns EqualityExpr
	 *     RelationalExpr.RelationalExpr_1_0 returns EqualityExpr
	 *     AdditiveExpr returns EqualityExpr
	 *     AdditiveExpr.AdditiveExpr_1_0 returns EqualityExpr
	 *     MultiplicativeExpr returns EqualityExpr
	 *     MultiplicativeExpr.MultiplicativeExpr_1_0 returns EqualityExpr
	 *     UnaryExpr returns EqualityExpr
	 *     PrimaryExpr returns EqualityExpr
	 *
	 * Constraint:
	 *     (left=EqualityExpr_EqualityExpr_1_0 right=RelationalExpr)
	 * </pre>
	 */
	protected void sequence_EqualityExpr(ISerializationContext context, EqualityExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.EQUALITY_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.EQUALITY_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.EQUALITY_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.EQUALITY_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityExprAccess().getEqualityExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityExprAccess().getRightRelationalExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condicion returns IntLiteral
	 *     Expression returns IntLiteral
	 *     OrExpr returns IntLiteral
	 *     OrExpr.OrExpr_1_0 returns IntLiteral
	 *     AndExpr returns IntLiteral
	 *     AndExpr.AndExpr_1_0 returns IntLiteral
	 *     EqualityExpr returns IntLiteral
	 *     EqualityExpr.EqualityExpr_1_0 returns IntLiteral
	 *     RelationalExpr returns IntLiteral
	 *     RelationalExpr.RelationalExpr_1_0 returns IntLiteral
	 *     AdditiveExpr returns IntLiteral
	 *     AdditiveExpr.AdditiveExpr_1_0 returns IntLiteral
	 *     MultiplicativeExpr returns IntLiteral
	 *     MultiplicativeExpr.MultiplicativeExpr_1_0 returns IntLiteral
	 *     UnaryExpr returns IntLiteral
	 *     PrimaryExpr returns IntLiteral
	 *     Literal returns IntLiteral
	 *     IntLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_IntLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.INT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.INT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condicion returns MultiplicativeExpr
	 *     Expression returns MultiplicativeExpr
	 *     OrExpr returns MultiplicativeExpr
	 *     OrExpr.OrExpr_1_0 returns MultiplicativeExpr
	 *     AndExpr returns MultiplicativeExpr
	 *     AndExpr.AndExpr_1_0 returns MultiplicativeExpr
	 *     EqualityExpr returns MultiplicativeExpr
	 *     EqualityExpr.EqualityExpr_1_0 returns MultiplicativeExpr
	 *     RelationalExpr returns MultiplicativeExpr
	 *     RelationalExpr.RelationalExpr_1_0 returns MultiplicativeExpr
	 *     AdditiveExpr returns MultiplicativeExpr
	 *     AdditiveExpr.AdditiveExpr_1_0 returns MultiplicativeExpr
	 *     MultiplicativeExpr returns MultiplicativeExpr
	 *     MultiplicativeExpr.MultiplicativeExpr_1_0 returns MultiplicativeExpr
	 *     UnaryExpr returns MultiplicativeExpr
	 *     PrimaryExpr returns MultiplicativeExpr
	 *
	 * Constraint:
	 *     (left=MultiplicativeExpr_MultiplicativeExpr_1_0 right=UnaryExpr)
	 * </pre>
	 */
	protected void sequence_MultiplicativeExpr(ISerializationContext context, MultiplicativeExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.MULTIPLICATIVE_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.MULTIPLICATIVE_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.MULTIPLICATIVE_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.MULTIPLICATIVE_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicativeExprAccess().getMultiplicativeExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicativeExprAccess().getRightUnaryExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condicion returns OrExpr
	 *     Expression returns OrExpr
	 *     OrExpr returns OrExpr
	 *     OrExpr.OrExpr_1_0 returns OrExpr
	 *     AndExpr returns OrExpr
	 *     AndExpr.AndExpr_1_0 returns OrExpr
	 *     EqualityExpr returns OrExpr
	 *     EqualityExpr.EqualityExpr_1_0 returns OrExpr
	 *     RelationalExpr returns OrExpr
	 *     RelationalExpr.RelationalExpr_1_0 returns OrExpr
	 *     AdditiveExpr returns OrExpr
	 *     AdditiveExpr.AdditiveExpr_1_0 returns OrExpr
	 *     MultiplicativeExpr returns OrExpr
	 *     MultiplicativeExpr.MultiplicativeExpr_1_0 returns OrExpr
	 *     UnaryExpr returns OrExpr
	 *     PrimaryExpr returns OrExpr
	 *
	 * Constraint:
	 *     (left=OrExpr_OrExpr_1_0 right=AndExpr)
	 * </pre>
	 */
	protected void sequence_OrExpr(ISerializationContext context, OrExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.OR_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.OR_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.OR_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.OR_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExprAccess().getOrExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExprAccess().getRightAndExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (name=ID cartas+=Carta+)
	 * </pre>
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condicion returns RelationalExpr
	 *     Expression returns RelationalExpr
	 *     OrExpr returns RelationalExpr
	 *     OrExpr.OrExpr_1_0 returns RelationalExpr
	 *     AndExpr returns RelationalExpr
	 *     AndExpr.AndExpr_1_0 returns RelationalExpr
	 *     EqualityExpr returns RelationalExpr
	 *     EqualityExpr.EqualityExpr_1_0 returns RelationalExpr
	 *     RelationalExpr returns RelationalExpr
	 *     RelationalExpr.RelationalExpr_1_0 returns RelationalExpr
	 *     AdditiveExpr returns RelationalExpr
	 *     AdditiveExpr.AdditiveExpr_1_0 returns RelationalExpr
	 *     MultiplicativeExpr returns RelationalExpr
	 *     MultiplicativeExpr.MultiplicativeExpr_1_0 returns RelationalExpr
	 *     UnaryExpr returns RelationalExpr
	 *     PrimaryExpr returns RelationalExpr
	 *
	 * Constraint:
	 *     (left=RelationalExpr_RelationalExpr_1_0 right=AdditiveExpr)
	 * </pre>
	 */
	protected void sequence_RelationalExpr(ISerializationContext context, RelationalExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.RELATIONAL_EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.RELATIONAL_EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.RELATIONAL_EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.RELATIONAL_EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalExprAccess().getRelationalExprLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationalExprAccess().getRightAdditiveExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Saludo returns Saludo
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Saludo(ISerializationContext context, Saludo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.SALUDO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.SALUDO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSaludoAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condicion returns StringLiteral
	 *     Expression returns StringLiteral
	 *     OrExpr returns StringLiteral
	 *     OrExpr.OrExpr_1_0 returns StringLiteral
	 *     AndExpr returns StringLiteral
	 *     AndExpr.AndExpr_1_0 returns StringLiteral
	 *     EqualityExpr returns StringLiteral
	 *     EqualityExpr.EqualityExpr_1_0 returns StringLiteral
	 *     RelationalExpr returns StringLiteral
	 *     RelationalExpr.RelationalExpr_1_0 returns StringLiteral
	 *     AdditiveExpr returns StringLiteral
	 *     AdditiveExpr.AdditiveExpr_1_0 returns StringLiteral
	 *     MultiplicativeExpr returns StringLiteral
	 *     MultiplicativeExpr.MultiplicativeExpr_1_0 returns StringLiteral
	 *     UnaryExpr returns StringLiteral
	 *     PrimaryExpr returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condicion returns NotExpr
	 *     Expression returns NotExpr
	 *     OrExpr returns NotExpr
	 *     OrExpr.OrExpr_1_0 returns NotExpr
	 *     AndExpr returns NotExpr
	 *     AndExpr.AndExpr_1_0 returns NotExpr
	 *     EqualityExpr returns NotExpr
	 *     EqualityExpr.EqualityExpr_1_0 returns NotExpr
	 *     RelationalExpr returns NotExpr
	 *     RelationalExpr.RelationalExpr_1_0 returns NotExpr
	 *     AdditiveExpr returns NotExpr
	 *     AdditiveExpr.AdditiveExpr_1_0 returns NotExpr
	 *     MultiplicativeExpr returns NotExpr
	 *     MultiplicativeExpr.MultiplicativeExpr_1_0 returns NotExpr
	 *     UnaryExpr returns NotExpr
	 *     PrimaryExpr returns NotExpr
	 *
	 * Constraint:
	 *     expr=PrimaryExpr
	 * </pre>
	 */
	protected void sequence_UnaryExpr(ISerializationContext context, NotExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.NOT_EXPR__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.NOT_EXPR__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExprAccess().getExprPrimaryExprParserRuleCall_0_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condicion returns VariableRef
	 *     Expression returns VariableRef
	 *     OrExpr returns VariableRef
	 *     OrExpr.OrExpr_1_0 returns VariableRef
	 *     AndExpr returns VariableRef
	 *     AndExpr.AndExpr_1_0 returns VariableRef
	 *     EqualityExpr returns VariableRef
	 *     EqualityExpr.EqualityExpr_1_0 returns VariableRef
	 *     RelationalExpr returns VariableRef
	 *     RelationalExpr.RelationalExpr_1_0 returns VariableRef
	 *     AdditiveExpr returns VariableRef
	 *     AdditiveExpr.AdditiveExpr_1_0 returns VariableRef
	 *     MultiplicativeExpr returns VariableRef
	 *     MultiplicativeExpr.MultiplicativeExpr_1_0 returns VariableRef
	 *     UnaryExpr returns VariableRef
	 *     PrimaryExpr returns VariableRef
	 *     VariableRef returns VariableRef
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DearCodePackage.Literals.VARIABLE_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DearCodePackage.Literals.VARIABLE_REF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableRefAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
