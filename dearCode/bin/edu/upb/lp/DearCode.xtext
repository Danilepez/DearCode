grammar edu.upb.lp.DearCode with org.eclipse.xtext.common.Terminals

generate dearCode "http://www.upb.edu/lp/DearCode"

Program:
    carta=Carta
;

Carta:
    saludo=Saludo
    cuerpo=Cuerpo
    despedida=Despedida
;

Saludo: ('Querido'|'Querida') name=ID '.';
Despedida: 'Con cariño, Tu programador' name=ID '.';
Cuerpo: instrucciones+=Instruccion+;

Instruccion:
    Declarar | Reasignar | Condicional 
    | BucleWhile | BucleFor | Entrada | Salida | Funcion | FunctionCall
;

Declarar:
    verboDecl=VerboDeclaracion
    articulo=Articulo
    sustantivo=MI_ID
    preComentario=Comment?
    valor=Expression
    postComentario=Comment?
    '.'
;

Reasignar:
    verboReas=VerboReasignacion
    preComentario=Comment?
    sustantivo=MI_ID
    postComentario=Comment?
    valor=Expression
    comentario=Comment?
    '.'
;

Entrada:
    'Le pedí al lector que me dijera' variable=MI_ID
    ("en un susurro numérico" | "con palabras de terciopelo")?
    '.'
;

Salida:
    'Hoy le quise contar al mundo sobre:' expresion=Expression '.'
;

ElementoBloque:
    Instruccion | Return
;

Condicional:
    'Si en tu corazon sientes que' condicion=Expression ','
        'entonces deja que estas palabras florezcan:'
        instruccionesThen+=ElementoBloque+
    ( 'Pero si el destino dijera lo contrario,'
        'que broten estas verdades:'
        instruccionesElse+=ElementoBloque+ )?
    'Y así el universo sigue su curso.'
;

BucleWhile:
    ('Mientras aun me piensas' | 'Mientras aún sueñes con este momento')
    condicion=Expression ','
    'haz que suceda:' 
    loopBody+=ElementoBloque+ 
    'Y así el susurro descansa.'  
;

BucleFor:
    'En cada suspiro' variable=MI_ID 'desde' inicio=Expression 
    'hasta' fin=Expression 
    ('con paso' paso=Expression)?  
    'deja que el universo cante:'
    loopBody+=ElementoBloque+ 
    'Cuando el último eco se calle.'  
;

Funcion:
    ('Dejo en estas líneas una promesa llamada' |
     'Escribo en estas líneas una intención llamada' |
     'En la brisa escondo un deseo llamado') name=MI_ID
    ('que guarda en su esencia' parametros+=MI_ID ('y' parametros+=MI_ID)*)? 
    ('prometiendo devolver' tipo=Type)? 
    'Cuando la promesa se cumple:'
        instrucciones+=ElementoBloque+ 
    'Así se sella la promesa.'
;

Return:
    'Y entrego al viento' expresion=Expression 'como promesa cumplida.'
;

// Sistema de expresiones
Expression:
    OrExpression
;

OrExpression returns Expression:
    AndExpression ({OrExpression.left=current} 
        (' o quizás ' | ' o quizás') right=AndExpression)*
;

AndExpression returns Expression:
    EqualityExpression ({AndExpression.left=current} 
        (' y también ' | ' y también') right=EqualityExpression)*
;

EqualityExpression returns Expression:
    RelationalExpression ({EqualityExpression.left=current} 
        op=('late al unísono con' | 'canta con un matiz distinto a') 
        right=RelationalExpression)*
;

RelationalExpression returns Expression:
    AdditiveExpression ({RelationalExpression.left=current} 
        op=('susurra con menos fuerza que' | 'casi suspira al mismo nivel que' |
            'arde con más pasión que' | 'rodea con tanta fuerza como') 
        right=AdditiveExpression)*
;

AdditiveExpression returns Expression:
    MultiplicativeExpression ({AdditiveExpression.left=current} 
        op=('unidos en un solo suspiro con' | 'fundidos en la llama de') 
        right=MultiplicativeExpression)*
;

MultiplicativeExpression returns Expression:
    UnaryExpression ({MultiplicativeExpression.left=current} 
        op=('fortalecidos por el fuego de' | 'separados entre los ecos de' | 'resuena con el eco de') 
        right=UnaryExpression)*
;

UnaryExpression returns Expression:
    {UnaryExpression} op=('no creo que') expression=UnaryExpression
    | PrimaryExpression
;

PrimaryExpression returns Expression:
    '(' Expression ')'
    | {NumberLiteral} valueInt=INT
    | {StringLiteral} valueString=STRING
    | {BooleanLiteral} valueBoolean=('siempre' | 'jamás')
    | {VariableReference} name=ID
    | FunctionCall
;

FunctionCall returns Expression:
    {FunctionCall}  // Esto fuerza a crear una clase concreta
    'invoco a' (nameFuncion=[MI_ID]) 
    comentario=Comment? 
    ('con los regalos' (args+=Expression ('y' args+=Expression)*)? 
    'en mi corazón')
;

// Sistema de tipos
Type: 'número' | 'texto' | 'booleano' | 'nada'; 

// Comentarios ultra-flexibles
Comment: 
    value=ANYTEXT
;

// Terminales
MI_ID: name=ID;
VerboDeclaracion: 'Te regalo' | 'Ofrezco' | 'Obsequio' | 'Deposito en tu jardín';
VerboReasignacion: 'Permíteme alimentar' | 'Permíteme regar' | 'Permíteme ajustar';
Articulo: 'un' | 'una';

terminal ANYTEXT:
    '~' 
    ( 
      // Cualquier caracter Unicode excepto ~ y salto de línea
      !('~' | '\n' | '\r') 
    )* 
    '~'
;